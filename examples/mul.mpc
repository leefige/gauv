/*
struct field {
    uint base;
};

template <field F>
struct par {
    uint idx;   // can be directly used as index
    F alpha;

    @contr
    par(F alpha);
};

// support iteration
template <field F>
struct parset {
    uint size;
    par<F> m_pars[size];

    par<F> operator[](uint idx);
};

template <field F, uint deg>
struct poly {
    par party;
    uint degree;
    F const;
    F coeffs[degree];

    F eval(par p);

    @contr
    poly{par p};
};

template <field F>
struct share {
    par party;
    F val;

    @contr
    share{par p};
};

// a number distributed onto all parties (can be reconstructed to that number??)
template <field F>
struct bundle {
    parset parties;
    share m_shares[parties.size];

    share operator[](par p);
};

template <field F>
struct matrix {
    par party;
    uint r;
    uint c;

    F get()(uint i, uint j);
    void set()(uint i, uint j, F v);

    matrix operator*(matrix other);

    matrix inv();

    @contr
    matrix{par p}(uint r, uint c);
};

proto:
    out(par p, field val);
    out(share{p} val);
    out(bundle vals);
*/

/*=================================================*/

template <field F>
macro vandermonde(parset<F> parties) -> matrix<F>{} {
    matrix<F>{} output(parties.size, parties.size);
    for (int i = 0; i < parties.size; i++) {
        for (int j = 0; j < parties.size; j++) {
            output.set(i, j, pow(parties[i].alpha, j));
        }
    }
    return output;
}

template <field F>
macro matrix_pt(parset<F> parties, uint T) -> matrix<F>{} {
    matrix<F>{} output(parties.size, parties.size);
    for (int i = 0; i < T; i++) {
        output.set(i, i, 1);
    }
    return output;
}

template <field F>
macro matrix_reduce(parset<F> parties, uint T) -> matrix<F>{} {
    matrix<F>{} van = vandermonde(parties);
    matrix<F>{} pt = matrix_pt(parties, T);
    return van * pt * van.inv();
}

/*=================================================*/


// no input
template <sec T, field F>
proto f_rand_2t(parset<F> parties) {
    // each party chooses a 2-t poly with constant 0: q_i(x)
    paral (par i : parties) {
        poly<F, 2 * T>{i} q_i = poly_gen(2 * T, 0);

        // send s_i,j = q_i(alpha_j) to j
        for (par j : parties) {
            share<F>{j} s_i_j = q_i.eval(j);
            i.send(j, s_i_j);
        }
    }

    // sync()?

    // each party i computes delta_i
    paral (par i : parties) {
        share<F>{i} delta_i = 0;
        for (par j : parties) {
            share<F>{i} s_j_i = i.recv(j);
            delta_i = delta_i + s_j_i;
        }

        // each party outputs delta_i
        out(delta_i);
    }
}

// this is supposed to be a local protocol
template <sec T, field F>
proto f_const_matmul(parset<F> parties, matrix<F>{} mat, bundle<F> vec[parties.size]) {
    // assert(mat.r == mat.c);
    // assert(mat.c == parties.size);
    paral (par p_i : parties) {
        share<F>{p_i} res_i = 0;
        for (int j = 0; j < parties.size; j++) {
            // local const mult gate & addition gate
            res_i = res_i + vec[j][p_i] * mat.get(p_i.idx, j);
        }
        out(res_i);
    }
}

// this is supposed to be a local protocol
template <sec T, field F>
proto f_deg_reduce(parset<F> parties, bundle<F> hs[parties.size]) {
    matrix<F>{} array = matrix_reduce(parties, T);
    bundle<F> trunc = f_const_matmul<T, F>(parties, array, hs);
    out(trunc);
}

// two shares mult protocol
template <sec T, field F>
proto f_mult(parset<F> parties, bundle<F> beta, bundle<F> gamma) {
    // local mul
    // WARNING: * means local share multiplication
    bundle<F> s = beta * gamma;

    // randomize
    bundle<F> sigma = f_rand_2t<T, F>(parties);
    bundle<F> randomized = s + sigma;

    // degree reduce
    bundle<F> delta = f_deg_reduce<T, F>(parties, randomized);

    out(delta);
}


/*
proto: unit of verification, take shares or numbers as inputs, use `out` to specify protocol output
sec T: T-privacy, T should be a uint (0, parites.size]
poly_gen: take a random tape as input
*/
