/*
struct field {
    uint base;
};

template <field F>
struct par {
    uint idx;   // can be directly used as index
    F alpha;

    @contr
    par(F alpha);
};

// support iteration
template <field F>
struct parset {
    uint size;
    par<F> m_pars[size];

    par<F> operator[](uint idx);
};

template <field F, uint deg>
struct poly {
    par party;
    uint degree;
    F const;
    F coeffs[degree];

    F eval(par p);

    @contr
    poly{par p};
};

template <field F>
struct share {
    par party;
    F val;

    @contr
    share{par p};
};

// a number distributed onto all parties (can be reconstructed to that number??)
template <field F>
struct bundle {
    parset parties;
    share m_shares[parties.size];
    
    share operator[](par p);
};

template <field F>
struct matrix {
    par party;

    F get()(uint i, uint j);
    void set()(uint i, uint j, F v);

    matrix operator@(matrix other);

    matrix inv();

    @contr
    matrix{par p}(uint r, uint c);
};

proto: 
    out(par p, field val);
    out(share{p} val);
    out(bundle vals);
*/

/*=================================================*/

template <field F>
macro vandermonde(parset<F> parties) -> matrix<F>{common} {
    matrix<F>{common} output(parties.size, parties.size);
    for (int i = 0; i < parties.size; i++) {
        for (int j = 0; j < parties.size; j++) {
            output.set(i, j, pow(parties[i].alpha, j));
        }
    }
    return output;
}

template <field F>
macro matrix_pt(parset<F> parties, uint T) -> matrix<F>{common} {
    matrix<F>{common} output(parties.size, parties.size);
    for (int i = 0; i < T; i++) {
        output.set(i, i, 1);
    }
    return output;
}

template <field F>
macro matrix_reduce(parset<F> parties, uint T) -> matrix<F>{common} {
    matrix<F>{common} van = vandermonde(parties);
    matrix<F>{common} pt = matrix_pt(parties, T);
    return van @ pt @ van.inv();
}

/*=================================================*/


template <sec T, field F>
proto rand_2t(parset<F> parties) {
    // no input

    paral (par i : parties) {
        // each party chooses a 2-t poly with constant 0: q_i(x)
        poly<F, 2 * T>{i} q_i = poly_gen(2 * T, 0);

        // send s_i,j = q_i(alpha_j) to j
        for (par j : parties) {
            share{j} s_i_j = q_i.eval(j);
            i.send(j, s_i_j);
        }
    }
    
    paral (par i : parties) {
        // each party i computes delta_i
        share{i} delta_i = 0;
        for (par j : parties) {
            share{i} s_j_i = i.recv(j);
            delta_i = delta_i + s_j_i;
        }

        // each party outputs delta_i
        out(delta_i);
    }
}

// this is supposed to be a local protocol
template <sec T, field F>
proto const_matmul(parset<F> parties, matrix<F>{common} array, bundle<F> vec[parties.size]) {
    paral (par p : parties) {

    }
}

// this is supposed to be a local protocol
template <sec T, field F>
proto deg_reduce(parset<F> parties, bundle<F> hs[parties.size]) {
    matrix<F>{common} array = matrix_reduce(parties, T);
    bundle<F> trunc = const_matmul<T, F>(parties, array, hs);
    out(trunc);
}

template <sec T, field F>
proto mult(parset<F> parties, bundle<F> beta, bundle<F> gamma) {
    // local mul
    // WARNING: * means local share multiplication
    bundle<F> s = beta * gamma;

    // randomize
    bundle<F> sigma = rand_2t<T, F>(parties);
    bundle<F> randomized = s + sigma;

    // degree reduce
    bundle<F> delta = deg_reduce<T, F>(parties, randomized);

    out(delta);
}


/*
proto: unit of verification, take shares or numbers as inputs, use `out` to specify protocol output
sec T: T-privacy, T should be an uint (0, parites.size]
poly_gen: take a random tape as input
*/
